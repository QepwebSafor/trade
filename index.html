<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/cerulean/bootstrap.min.css" integrity="sha384-3fdgwJw17Bi87e1QQ4fsLn4rUFqWw//KU0g8TvV6quvahISRewev6/EocKNuJmEw" crossorigin="anonymous">
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>   
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <a class="navbar-brand" href="#"><span>Curso Git </span></a>   
          <ul class="navbar-nav ml-auto">
            <li class="nav-item active">
              <a class="nav-link" href="./index.html">Flujo de trabajo <span class="sr-only">(current)</span></a>
            </li>       
            <li class="nav-item">
              <a class="nav-link" href="./comandos.html">Comandos</a>
            </li>
          </ul>     
      </nav> 
    <div class="App">
    <div id="container-fluid">  
        <div id="post">
          <h3>¿Que es el staging y los repositorios?</h3>
          <p>
            Para iniciar un repositorio, o sea, activar el sistema de control de versiones de Git en el proyecto, solo debes  ejecutar el comando <span>$ git init</span>.
Este comando se encargará de dos cosas: primero , crear una carpeta<span> .git</span>, donde se guardará todas la base de datos con cambios atómicos de nuestro proyecto; y segundo, creará un área conocida como <span>Staging</span> , que guardará temporalmente nuestros archivos cuando ejecutemos el comando add y nos permitirá, más adelante, guardar  estos cambios en el repositorio  con el comando commit.</p>

<h3>Ciclo de vida o estados de los archivos en Git:</h3>
<p>Cuando trabajamos con git nuestros archivos pueden vivir y moverse entre 4 estados diferentes (cuando trabajamos con repositorios remotos pueden ser más estados):</p>
<ul class="list-group">
<li> Archivos <span>tracked</span>: son los archivos que viven dentro de Git, no tienen cambios pendientes y sus últimas actualizaciones han sido guardadas en el repositorio gracias a los comandos git add y git commit.</li>

<li> Archivos <span>Staged</span>: son archivos en Staging. Viven dentro de GIt y  son los que han sido  añadidos por el comando git add, aunque no se han consolidado sus cambios. Git sabe de la existencia de estos cambios, pero no han sido guardados definitivamente en el repositorio porque falta ejecutar el comando commit.
</li>
<li> Archivos <span> Unstaged</span>: son  como archivos en tracked pero Unstaged. Son archivos que viven en Git pero  no se les ha aplicado el comando git add ni el git commit. Git tiene un registro de estos archivos, pero no están actualizados, solo están guardadas sus últimas versiones  en el disco duro.
</li>
 <li> Archivos <span>Untracked</span>: son archivos que no viven dentro de Git, sólo en el disco duro. No se les ha aplicado git add, así que Git no tiene registro de su existencia. Solo hay un caso muy raro donde los archivos tienen dos estados al mismo tiempo: <span>staged y untracked</span>. Esto pasa cuando guardas cambios con el comando git add, y antes de hacer el commit haces nuevos cambios que no estan en el Staging porque  no has aplicado git add.
</li>
</ul>
</p>
<h3>Comandos para mover archivos entre los estados de Git </h3>

<ul class="list-group">
 <li><span>$ git status: </span>nos permite ver el estado de todos nuestros archivos y carpetas.</li>
 <li><span>$ git add:</span> nos ayuda a mover archivos del Untracked o Unstaged al estado Staged. Podemos usar <span>$ git add nombre-del-archivo-o-carpeta</span>para añadir archivos y carpetas individuales o <span>$ git add -A </span>
  para mover todos los archivos de nuestro proyecto ( tanto los Untracked como los Unstaged).</li>
 <li> <span>$ git reset HEAD: </span> nos ayuda a traer archivos del estado Staged para devolverlos a su estado anterior. Si estaban los archivos en Unstaged, vuelven allí. Asi tambien como si estaban en Untracked.</li>
 <li><span>$ git commit:</span> nos ayuda a llevar archivos del estado Unstaged al estado Tracked.Este es el estado donde los archivos han sido guardados o actualizados en el repositorio. Git nos pedirá que dejemos un mensaje para recordar los cambios realizados y con el argumento -m escribirlo. (git commit -m).</li>
 <li><span>$ git rm:</span> este comando necesita alguno de los siguientes argumento para poder ejecutarse correctamente:
    <ul class="list-group">
 <li><span>$ git rm --cached:</span> Lleva los archivos que le indiquemos al estado Untracked.</li>
  <li><span>$ git rm --force:</span> Elimina los archivos de Git  y del disco duro. Git guarda el registro de la existencia de  los archivos, por lo que podremos recuperarlos si es necesario usando comandos más avanzados.</li></ul></li>

</ul>
<h3>Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h3>

<p>
El comando <span>$ git checkout + ID del commit</span> nos permite viajar en el tiempo. Podremos volver a cualquier versión anterior de un archivo específico o incluso del proyecto entero. Esta es la forma de crear ramas y movernos entre ellas.
 
 Usando el comando </span>git reset</span> volvemos en el tiempo y borramos los cambios que hicimos después de este commit.

 Git reset y git rm son comandos con utilidades muy diferentes, pero aún así se confunden muy fácilmente.

<h3>git rm</h3>

<p>
  Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo solo debemos "viajar en el tiempo" y recuperar el último commit antes de borrar el archivo en cuestión.

  Recuerda que git rm no puede usarse porque si. Debemos usar uno de los flags para indicarle a Git cómo eliminar los archivos que ya no necesitamos en la última versión del proyecto:
<ul class="list-group">
   <li><span>$ git rm --cached: </span>
      Elimina los archivos de nuestro repositorio local y el área de staging, pero los mantiene en nuestro disco duro. Básicamente le dice a GIT que deje de trackear el historial de cambios de estos archivos, por lo que pasarán a un estado untracked.</li> 
   <li> <span>$ git rm --force:</span>
      Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario ( pero  debemos usar comandos más avanzados).> </li>
   
  </ul>
</p>
  <h3>git reset</h3>  
  <p>
   Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta a atrás.

   Este comando es muy peligroso y debemos usarlo solo en caso de emergencia. Recordar que debemos usar algunas de estas dos opciones:

 
  </p>
<ul class="list-group">
    <li><span>$ git reset --soft: </span> todo el historial y los registros de Git pero guardamos los cambios que tengamos en staging, así podemos aplicar las últimas actualizaciónes a un nuevo commit. Mantiene  los archivos del área de staging para que podamos aplicar nuestros últimos cambios pero desde un commit anterior.</li>

<li> <span>$ git reset --hard: </span>Borra todo. Todo todito, absolutamente todo. Toda la información de los commit y del área de staging se borra del historial.
    Borra toda la información que tengamos en el área de staging ( y perdiendo todo para siempre)</li>

<li> <span>$ git reset HEAD:</span> este es el comando para sacar archivos del área de stagin. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión  y los incluyamos de nuevo en staging con git add, por supuesto.</li>

</ul>

<h3>¿Cuando usar git rm y git reset HEAD?</h3>
 <p>  
     Bueno, todos los cambios están en el área de Staging, incluido el archivo con los cambios que no están listos. Esto significa que debemos sacar ese archivo del Staging para poder hacer commit de todos los demás.</p>
<p>
    Con <span>$ git rm</span></git> lo que haremos será eliminar este archivo completamente de git! Todavía tendremos el historial de cambios de este archivo, con la eliminacion del archivo como su última actualización. Recuerda que en este caso no buscábamos eliminar un archivo, solo dejarlo como estaba y actualizado después, no en este commit.
  </p>
  <p>
     En cambio scon <span>$ git reset HEAD</span>, lo único que harémos será move estos cambios de Staging a Unstaged. Seguiremos teniendo los últimos cambios en el archivo, el repositorio mantendrá el archivo ( no con sus últimos cambios pero si con los últimos en los que hicimos commit) y no habremos perdido nada.
    </p>
    <h3>Introducción a las ramas o branches de Git</h3>
   
<p>
    Las ramas son la forma de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de la rama principal. Esto es porque queremos trabajar una parte muy especifica de la aplicación o simplemente experimentar.
    La cabecera o HEAD representa la rama y el commit de esa rama donde estamos trabajando. Por defecto, esta cabecera aparecerá en el ultimo commit de nuestra rama principal. Pero podemos cambiarlo: <span>$ git checkout -b rama</span> o crear una rama: <span>$ git branch rama</span> o movernos en el tiempo a cualquier otro commit de cualquier otra rama con los comandos: <span>$ git reset id-commit</span> o <span>$ git checkout rama-o-id-commit</span>.
  </p>
  <h3>Cómo funcionan las llaves públicas y privadas</h3>
<p>
Las llaves publicas y privadas nos ayudan a cifrar y descifrar nuestros archivos de forma que los podamos compartir sin correr el riesgo de que sean interceptados por personas con malas intenciones.</p>
<p></p>
La forma de hacerlo es la siguiente:
<ol>
  <li> Ambas personas deben crear su llave pública y privada.</li>
<li> Ambas personas pueden compartir su llave pública a las otras partes. </li>(recuerda que esta llave es pública, no hay problema si la "interceptan").
<li> La persona que quiera compartir un mensaje puede usar la llave pública de la otra persona para cifrar los archivos y asegurarse que solo puedan ser descifrados con la llave privada de la persona con la que queremos compartir el mensaje.</li>
<li> El mensaje está cifrado y puede ser enviado a otra persona sin problemas en caso de que los archivos sean interceptados.</li>
<li> La persona a la que enviamos el mensaje cifrado puede usar su llave privada para descrifrar el mensaje y ver los archivos.</li>
</ol>
<h3>Configurar las llaves ssh en local</h3>

<ul>
<li>1er paso: generar tus llaves SSH. La llave privada puede ir protegida con una contraseña.

<p>
<span>ssh-keygen -t rsa -b 4096 -C "tu@email.com"</span>
</p>

</li>
<li>2º paso : terminar de configurar nuestro sistema.

En Windows:
<ol>
<li> Encender el "servidor" de llaves SSH de tu computadora
 <span>eval $(ssh-agent -s)</span>
</li><li>
  Añadir tu llave SSH a este "servidor"

 <span>ssh-add ruta-donde-guardaste-tu-llave-privada</span>
</li>
</ol>
</li>
</ul>
<h3>Conexión a GitHub con SSH</h3>
<p>
Solo se crean  una SSH por computadora.
</p>
<p>
Después de crear nuestras llaves SSH podemos entregarle la llave pública a gitHub para comunicarnos de forma segura y sin necesidad de escribir nuestro usuario y contraseña todo el tiempo.
</p>
<p>
Para esto entrarás a la COnfiguración de llaves SSH en GITHUB, crear una nueva llave con el nombre que le quieras dar y el contenido de la llave pública de tu computadora.
</p>
<p>
Ahora podemos actualizar la URL que guardamos en nuestro repositorio remoto, solo que en vez de guardar la URL con HTTPS, vamos a usar la URL con SSH:

<p>
<span>$ git remote set-url origin url-ssh-del-repositorio-en-gitHub</span>
</p>
<h3>Tags o etiquetas</h3>
<p>
Las tags o etiquetas nos permiten asignar versiones a los commits con los cambios más importantes o significativos de nuestro proyecto.
</p>
Comandos para trabajar con etiquetas:

  <ul>
<li>Crear un nuevo tag y asignarlo a un commit:<br>

<span>$ git tag -a nombre-del-tag id-del-commit</span></li>

<li> Borrar un tag en el repositorio local:<br>

<span>$ git tag -d nombre-del-tag</span></li>

<li>Listar los tags de nuestro repositorio local:<br>

<span>$ git tag</span></li>
</uL>

<h3>Flujo de trabajo básico con un repositorio remoto</h3>

<p>
Por ahora, nuestro proyecto vive únicamente en nuestra computadora. Esto significa que  no hay forma de que otros miembros del equipo trabajen el él.
</p>
<p>
Para solucionar esto están los servidores remotos: un nuevo estado que deben seguir nuestros archivos para conectarse y trabajar con equipos de cualquier parte del mundo.
</p>
<p>
Estos servidores remotos pueden estar alojados en GITHUB, GITLAB, BitBucket, entre otros. Lo que van a hacer es guardar el mismo repositorio que tienes en tu computadora y darnos una URL con la que todos podremos acceder a los archivos del proyecto para descargarlos, hacer cambios y volverlos a enviar al servidor remoto para que otras personas vean los cambios, comparen sus versiones y creen nuevas propuestas para el proyecto.
</p>
Esto significa que debes aprendender algunos nuevos comandos:
<ul>
<li> <span>$ git clone url_del_servidor_remoto</span>:  Nos permite descargar los archivos de la última  versión de la rama principal y todo el historial de cambios en la carpeta .git.</li>

<li> <span>$ git push</span>: Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.</li>
</li>
<li> <span>$ git fetch</span>: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local ( en caso de haberlas).</li>

<li><span>$ git merge</span>: Tambien usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo.</li>

<li> <span>$ git pull</span>: Básicamente, git fetch y git merge al mismo tiempo.</li>
</ul>
<h3>Flujo de trabajo profesional con pull request</h3>
<p>

En un entorno profesional normalmente se bloquea la rama master, y para enviar código a dicha rama pasa por un code review y  si se aprueba se unen los códigos con los llamados merge request.
</p>
<p>
Para analizar pruebas enviamos el código a servidores que normalmente los llamamos staging develop(servidores de pruebas) al realizar las pruebas pertinenetes tanto del código como de la aplicación estos pasan al servidor de producción con el ya antes mencionado merge request.
</p>
<h3>git rebase: reorganizar el trabajo realizado</h3>
<p>

El comando rebase es una mala práctica, nunca se debe usar, pero para efectos del tutorial lo veremos para hacer tus propios experimentos. Con rebase puedes recoger todos los cambios confirmados en una rama y ponerlos sobre otra.
</p>
<ul>

<li> Cambiamos a la rama que queremos traer los cambios
<span>$ git checkout experiment</span>
</li>
<li> Aplicamos rebase para traer los cambios de la rama que queremos
<span>$ git rebase main</span>
</li>
</ul>
<h3>git stash: guardar cambios en memoria y recuperarlos después</h3>

<p>

Cuando necesitemos regresar en el tiempo porque borramos alguna línea de código pero no queremos pasarnos a otra rama porque nos daría un error al tener que pasar por ese "mal cambio" que hicimos en stage, podremos usar <span>$ git stash</span> y regresar así al cambio anterior que hicimos.
</p>
<span>$ git stash</span> es típico cuando hacemos cambios que no merecen una rama o no merecen un rebase si no que  simplemente estamos probando algo y queremos volver rápidamente a la versión anterior que es la correcta.
<h3>git clean: limpiar tu proyecto de archivos no deseados</h3>

<p>A veces creas archivos cuando estas realizando proyectos y que realmente no forman parte de nuestro directorio de trabajo, que no los deberias agregar y lo sabes.</p>

<ul>
<li>Para saber que archivos son los que vamos a borrar tecleamos:<br>
  <span>$ git clean --dry-run</span></li> 

 <li>Para borrar todos los archivos listados (que no sean carpetas) tecleamos:<br>

 <span>$ git clean -f </span>       </li>  
</ul>
<h3>git cherry-pick: traer commits viejos al head de un branch</h3>
<P>

Existe un mundo alternativo en el cual vamos avanzado en una rama pero necesitamos en main uno de estos avances de la rama, para esto utilizaremos el comando :<bR>

       <span>$ git cherry-pick IDCommit.</span> <br>

cherry-pick es una mala práctica porque significa que estamos reconstruyendo la historia,  usa cherry-pick con conocimiento de causa. No saber que es lo que estas haciendo  es peligroso.
</P>
<h3>Reconstruir commits en git con ammend</h3>

<p>


 A veces hacemos un commit, pero resulta que no lo queremos mandar porque faltaba algo más. Utilizamos:

            <span>$ git commit --amend</span><br>

  amend en inglés es remendar y lo que hará es que los cambios que hicimos nos los agregará al commit anterior.  
  
</p>
<h3>git reset y reflog: únase en caso de emergencia</h3>

<p>
¿Que pasa cuando todo se rompe y no sabemos que está pasando? Con:<br>


       <span>$ git reset HashDelHEAD </span> <br>

volveremos al estado en que el proyecto funcionaba:
</p>
<ul>
<li><span>$ git reset --soft HashDelHEAD:</span> te mantiene lo que tengas en staging ahí.</li> 
<li><span>$ git reset --hard HashDelHEAD:</span> resetea absolutamente todo lo que tengas en staging.</li> 
</ul>
<p>
git reset es una mala práctica, se recomienda no usarlo; debe ser el último recurso.
</p>
<h3>Buscar en archivos y commits de git con grep y log</h3>
<p>

A medida que se hace más grande el proyecto quieres ir buscando más cosas.
Por ejemplo, ¿ Cuantas veces en nuestro proyecto buscamos la palabra color?
</p>
<ul>
<li>Con <span>$ git grep -n color </span>  nos saldrá un output que nos dirá en que línea está lo que estamos buscando.</li> 
<li> Con  <span>$ git grep -c color</span> nos saldrá un output que nos dirá cuantas veces se repite esa palabra y en que archivos.</li>

<li> Si queremos buscar cuántas veces utilizamos un atributo de HTML lo hacemos con  
  <span>$ git grep -c "etiqueta html"</span></li> 

<li>Si queremos buscar en los commits, por ejemplo la palabra cabecera lo hacemos con: 

  <span>$ git log -S cabecera</span></li> 
</ul>

        </div>
  
      </div>
      </div>
      <div id="footer">
        Lecturas de Git- documentation.https://git-scm.com/docs/
      </div>
     
  </body>
</html>
