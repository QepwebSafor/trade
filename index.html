<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<<<<<<< HEAD
    <title>Document</title>
=======
    <title>Curso Trade</title>
>>>>>>> 164800e4233961b6e0bb0fed760c1a47413df8c5
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/cerulean/bootstrap.min.css" integrity="sha384-3fdgwJw17Bi87e1QQ4fsLn4rUFqWw//KU0g8TvV6quvahISRewev6/EocKNuJmEw" crossorigin="anonymous">
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>   
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
<<<<<<< HEAD
        <a class="navbar-brand" href="#"><span>Curso Git </span></a>   
          <ul class="navbar-nav ml-auto">
            <li class="nav-item active">
              <a class="nav-link" href="./index.html">Flujo de trabajo <span class="sr-only">(current)</span></a>
            </li>       
            <li class="nav-item">
              <a class="nav-link" href="./comandos.html">Comandos</a>
            </li>
=======
        <a class="navbar-brand" href="#">Introduccion al trading con criptomonedas </a>
     
          <ul class="navbar-nav ml-auto">
            <li class="nav-item active">
              <a class="nav-link" href="./index.html">Tecnicas de trading <span class="sr-only">(current)</span></a>
            </li>       
       
>>>>>>> 164800e4233961b6e0bb0fed760c1a47413df8c5
          </ul>     
      </nav> 
    <div class="App">
    <div id="container-fluid">  
<<<<<<< HEAD
        <div id="post">
          <h3>¿Que es el staging y los repositorios?</h3>
          <p>
            Para iniciar un repositorio, o sea, activar el sistema de control de versiones de Git en el proyecto, solo debes  ejecutar el comando <span>$ git init</span>.
Este comando se encargará de dos cosas: primero , crear una carpeta<span> .git</span>, donde se guardará todas la base de datos con cambios atómicos de nuestro proyecto; y segundo, creará un área conocida como <span>Staging</span> , que guardará temporalmente nuestros archivos cuando ejecutemos el comando add y nos permitirá, más adelante, guardar  estos cambios en el repositorio  con el comando commit.</p>

<h3>Ciclo de vida o estados de los archivos en Git:</h3>
<p>Cuando trabajamos con git nuestros archivos pueden vivir y moverse entre 4 estados diferentes (cuando trabajamos con repositorios remotos pueden ser más estados):</p>
<ul class="list-group">
<li> Archivos <span>tracked</span>: son los archivos que viven dentro de Git, no tienen cambios pendientes y sus últimas actualizaciones han sido guardadas en el repositorio gracias a los comandos git add y git commit.</li>

<li> Archivos <span>Staged</span>: son archivos en Staging. Viven dentro de GIt y  son los que han sido  añadidos por el comando git add, aunque no se han consolidado sus cambios. Git sabe de la existencia de estos cambios, pero no han sido guardados definitivamente en el repositorio porque falta ejecutar el comando commit.
</li>
<li> Archivos <span> Unstaged</span>: son  como archivos en tracked pero Unstaged. Son archivos que viven en Git pero  no se les ha aplicado el comando git add ni el git commit. Git tiene un registro de estos archivos, pero no están actualizados, solo están guardadas sus últimas versiones  en el disco duro.
</li>
 <li> Archivos <span>Untracked</span>: son archivos que no viven dentro de Git, sólo en el disco duro. No se les ha aplicado git add, así que Git no tiene registro de su existencia. Solo hay un caso muy raro donde los archivos tienen dos estados al mismo tiempo: <span>staged y untracked</span>. Esto pasa cuando guardas cambios con el comando git add, y antes de hacer el commit haces nuevos cambios que no estan en el Staging porque  no has aplicado git add.
</li>
</ul>
</p>
<h3>Comandos para mover archivos entre los estados de Git </h3>

<ul class="list-group">
 <li><span>$ git status: </span>nos permite ver el estado de todos nuestros archivos y carpetas.</li>
 <li><span>$ git add:</span> nos ayuda a mover archivos del Untracked o Unstaged al estado Staged. Podemos usar <span>$ git add nombre-del-archivo-o-carpeta</span>para añadir archivos y carpetas individuales o <span>$ git add -A </span>
  para mover todos los archivos de nuestro proyecto ( tanto los Untracked como los Unstaged).</li>
 <li> <span>$ git reset HEAD: </span> nos ayuda a traer archivos del estado Staged para devolverlos a su estado anterior. Si estaban los archivos en Unstaged, vuelven allí. Asi tambien como si estaban en Untracked.</li>
 <li><span>$ git commit:</span> nos ayuda a llevar archivos del estado Unstaged al estado Tracked.Este es el estado donde los archivos han sido guardados o actualizados en el repositorio. Git nos pedirá que dejemos un mensaje para recordar los cambios realizados y con el argumento -m escribirlo. (git commit -m).</li>
 <li><span>$ git rm:</span> este comando necesita alguno de los siguientes argumento para poder ejecutarse correctamente:
    <ul class="list-group">
 <li><span>$ git rm --cached:</span> Lleva los archivos que le indiquemos al estado Untracked.</li>
  <li><span>$ git rm --force:</span> Elimina los archivos de Git  y del disco duro. Git guarda el registro de la existencia de  los archivos, por lo que podremos recuperarlos si es necesario usando comandos más avanzados.</li></ul></li>

</ul>
<h3>Volver en el tiempo en nuestro repositorio utilizando reset y checkout</h3>

<p>
El comando <span>$ git checkout + ID del commit</span> nos permite viajar en el tiempo. Podremos volver a cualquier versión anterior de un archivo específico o incluso del proyecto entero. Esta es la forma de crear ramas y movernos entre ellas.
 
 Usando el comando </span>git reset</span> volvemos en el tiempo y borramos los cambios que hicimos después de este commit.

 Git reset y git rm son comandos con utilidades muy diferentes, pero aún así se confunden muy fácilmente.

<h3>git rm</h3>

<p>
  Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo solo debemos "viajar en el tiempo" y recuperar el último commit antes de borrar el archivo en cuestión.

  Recuerda que git rm no puede usarse porque si. Debemos usar uno de los flags para indicarle a Git cómo eliminar los archivos que ya no necesitamos en la última versión del proyecto:
<ul class="list-group">
   <li><span>$ git rm --cached: </span>
      Elimina los archivos de nuestro repositorio local y el área de staging, pero los mantiene en nuestro disco duro. Básicamente le dice a GIT que deje de trackear el historial de cambios de estos archivos, por lo que pasarán a un estado untracked.</li> 
   <li> <span>$ git rm --force:</span>
      Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario ( pero  debemos usar comandos más avanzados).> </li>
   
  </ul>
</p>
  <h3>git reset</h3>  
  <p>
   Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta a atrás.

   Este comando es muy peligroso y debemos usarlo solo en caso de emergencia. Recordar que debemos usar algunas de estas dos opciones:

 
  </p>
<ul class="list-group">
    <li><span>$ git reset --soft: </span> todo el historial y los registros de Git pero guardamos los cambios que tengamos en staging, así podemos aplicar las últimas actualizaciónes a un nuevo commit. Mantiene  los archivos del área de staging para que podamos aplicar nuestros últimos cambios pero desde un commit anterior.</li>

<li> <span>$ git reset --hard: </span>Borra todo. Todo todito, absolutamente todo. Toda la información de los commit y del área de staging se borra del historial.
    Borra toda la información que tengamos en el área de staging ( y perdiendo todo para siempre)</li>

<li> <span>$ git reset HEAD:</span> este es el comando para sacar archivos del área de stagin. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión  y los incluyamos de nuevo en staging con git add, por supuesto.</li>

</ul>

<h3>¿Cuando usar git rm y git reset HEAD?</h3>
 <p>  
     Bueno, todos los cambios están en el área de Staging, incluido el archivo con los cambios que no están listos. Esto significa que debemos sacar ese archivo del Staging para poder hacer commit de todos los demás.</p>
<p>
    Con <span>$ git rm</span></git> lo que haremos será eliminar este archivo completamente de git! Todavía tendremos el historial de cambios de este archivo, con la eliminacion del archivo como su última actualización. Recuerda que en este caso no buscábamos eliminar un archivo, solo dejarlo como estaba y actualizado después, no en este commit.
  </p>
  <p>
     En cambio scon <span>$ git reset HEAD</span>, lo único que harémos será move estos cambios de Staging a Unstaged. Seguiremos teniendo los últimos cambios en el archivo, el repositorio mantendrá el archivo ( no con sus últimos cambios pero si con los últimos en los que hicimos commit) y no habremos perdido nada.
    </p>
    <h3>Introducción a las ramas o branches de Git</h3>
   
<p>
    Las ramas son la forma de hacer cambios en nuestro proyecto sin afectar el flujo de trabajo de la rama principal. Esto es porque queremos trabajar una parte muy especifica de la aplicación o simplemente experimentar.
    La cabecera o HEAD representa la rama y el commit de esa rama donde estamos trabajando. Por defecto, esta cabecera aparecerá en el ultimo commit de nuestra rama principal. Pero podemos cambiarlo: <span>$ git checkout -b rama</span> o crear una rama: <span>$ git branch rama</span> o movernos en el tiempo a cualquier otro commit de cualquier otra rama con los comandos: <span>$ git reset id-commit</span> o <span>$ git checkout rama-o-id-commit</span>.
  </p>
  <h3>Cómo funcionan las llaves públicas y privadas</h3>
<p>
Las llaves publicas y privadas nos ayudan a cifrar y descifrar nuestros archivos de forma que los podamos compartir sin correr el riesgo de que sean interceptados por personas con malas intenciones.</p>
<p></p>
La forma de hacerlo es la siguiente:
<ol>
  <li> Ambas personas deben crear su llave pública y privada.</li>
<li> Ambas personas pueden compartir su llave pública a las otras partes. </li>(recuerda que esta llave es pública, no hay problema si la "interceptan").
<li> La persona que quiera compartir un mensaje puede usar la llave pública de la otra persona para cifrar los archivos y asegurarse que solo puedan ser descifrados con la llave privada de la persona con la que queremos compartir el mensaje.</li>
<li> El mensaje está cifrado y puede ser enviado a otra persona sin problemas en caso de que los archivos sean interceptados.</li>
<li> La persona a la que enviamos el mensaje cifrado puede usar su llave privada para descrifrar el mensaje y ver los archivos.</li>
</ol>
<h3>Configurar las llaves ssh en local</h3>

<ul>
<li>1er paso: generar tus llaves SSH. La llave privada puede ir protegida con una contraseña.

<p>
<span>ssh-keygen -t rsa -b 4096 -C "tu@email.com"</span>
</p>

</li>
<li>2º paso : terminar de configurar nuestro sistema.

En Windows:
<ol>
<li> Encender el "servidor" de llaves SSH de tu computadora
 <span>eval $(ssh-agent -s)</span>
</li><li>
  Añadir tu llave SSH a este "servidor"

 <span>ssh-add ruta-donde-guardaste-tu-llave-privada</span>
</li>
</ol>
</li>
</ul>
<h3>Conexión a GitHub con SSH</h3>
<p>
Solo se crean  una SSH por computadora.
</p>
<p>
Después de crear nuestras llaves SSH podemos entregarle la llave pública a gitHub para comunicarnos de forma segura y sin necesidad de escribir nuestro usuario y contraseña todo el tiempo.
</p>
<p>
Para esto entrarás a la COnfiguración de llaves SSH en GITHUB, crear una nueva llave con el nombre que le quieras dar y el contenido de la llave pública de tu computadora.
</p>
<p>
Ahora podemos actualizar la URL que guardamos en nuestro repositorio remoto, solo que en vez de guardar la URL con HTTPS, vamos a usar la URL con SSH:

<p>
<span>$ git remote set-url origin url-ssh-del-repositorio-en-gitHub</span>
</p>
<h3>Tags o etiquetas</h3>
<p>
Las tags o etiquetas nos permiten asignar versiones a los commits con los cambios más importantes o significativos de nuestro proyecto.
</p>
Comandos para trabajar con etiquetas:

  <ul>
<li>Crear un nuevo tag y asignarlo a un commit:<br>

<span>$ git tag -a nombre-del-tag id-del-commit</span></li>

<li> Borrar un tag en el repositorio local:<br>

<span>$ git tag -d nombre-del-tag</span></li>

<li>Listar los tags de nuestro repositorio local:<br>

<span>$ git tag</span></li>
</uL>

<h3>Flujo de trabajo básico con un repositorio remoto</h3>

<p>
Por ahora, nuestro proyecto vive únicamente en nuestra computadora. Esto significa que  no hay forma de que otros miembros del equipo trabajen el él.
</p>
<p>
Para solucionar esto están los servidores remotos: un nuevo estado que deben seguir nuestros archivos para conectarse y trabajar con equipos de cualquier parte del mundo.
</p>
<p>
Estos servidores remotos pueden estar alojados en GITHUB, GITLAB, BitBucket, entre otros. Lo que van a hacer es guardar el mismo repositorio que tienes en tu computadora y darnos una URL con la que todos podremos acceder a los archivos del proyecto para descargarlos, hacer cambios y volverlos a enviar al servidor remoto para que otras personas vean los cambios, comparen sus versiones y creen nuevas propuestas para el proyecto.
</p>
Esto significa que debes aprendender algunos nuevos comandos:
<ul>
<li> <span>$ git clone url_del_servidor_remoto</span>:  Nos permite descargar los archivos de la última  versión de la rama principal y todo el historial de cambios en la carpeta .git.</li>

<li> <span>$ git push</span>: Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.</li>
</li>
<li> <span>$ git fetch</span>: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local ( en caso de haberlas).</li>

<li><span>$ git merge</span>: Tambien usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo.</li>

<li> <span>$ git pull</span>: Básicamente, git fetch y git merge al mismo tiempo.</li>
</ul>
<h3>Flujo de trabajo profesional con pull request</h3>
<p>

En un entorno profesional normalmente se bloquea la rama master, y para enviar código a dicha rama pasa por un code review y  si se aprueba se unen los códigos con los llamados merge request.
</p>
<p>
Para analizar pruebas enviamos el código a servidores que normalmente los llamamos staging develop(servidores de pruebas) al realizar las pruebas pertinenetes tanto del código como de la aplicación estos pasan al servidor de producción con el ya antes mencionado merge request.
</p>
<h3>git rebase: reorganizar el trabajo realizado</h3>
<p>

El comando rebase es una mala práctica, nunca se debe usar, pero para efectos del tutorial lo veremos para hacer tus propios experimentos. Con rebase puedes recoger todos los cambios confirmados en una rama y ponerlos sobre otra.
</p>
<ul>

<li> Cambiamos a la rama que queremos traer los cambios
<span>$ git checkout experiment</span>
</li>
<li> Aplicamos rebase para traer los cambios de la rama que queremos
<span>$ git rebase main</span>
</li>
</ul>
<h3>git stash: guardar cambios en memoria y recuperarlos después</h3>

<p>

Cuando necesitemos regresar en el tiempo porque borramos alguna línea de código pero no queremos pasarnos a otra rama porque nos daría un error al tener que pasar por ese "mal cambio" que hicimos en stage, podremos usar <span>$ git stash</span> y regresar así al cambio anterior que hicimos.
</p>
<span>$ git stash</span> es típico cuando hacemos cambios que no merecen una rama o no merecen un rebase si no que  simplemente estamos probando algo y queremos volver rápidamente a la versión anterior que es la correcta.
<h3>git clean: limpiar tu proyecto de archivos no deseados</h3>

<p>A veces creas archivos cuando estas realizando proyectos y que realmente no forman parte de nuestro directorio de trabajo, que no los deberias agregar y lo sabes.</p>

<ul>
<li>Para saber que archivos son los que vamos a borrar tecleamos:<br>
  <span>$ git clean --dry-run</span></li> 

 <li>Para borrar todos los archivos listados (que no sean carpetas) tecleamos:<br>

 <span>$ git clean -f </span>       </li>  
</ul>
<h3>git cherry-pick: traer commits viejos al head de un branch</h3>
<P>

Existe un mundo alternativo en el cual vamos avanzado en una rama pero necesitamos en main uno de estos avances de la rama, para esto utilizaremos el comando :<bR>

       <span>$ git cherry-pick IDCommit.</span> <br>

cherry-pick es una mala práctica porque significa que estamos reconstruyendo la historia,  usa cherry-pick con conocimiento de causa. No saber que es lo que estas haciendo  es peligroso.
</P>
<h3>Reconstruir commits en git con ammend</h3>

<p>


 A veces hacemos un commit, pero resulta que no lo queremos mandar porque faltaba algo más. Utilizamos:

            <span>$ git commit --amend</span><br>

  amend en inglés es remendar y lo que hará es que los cambios que hicimos nos los agregará al commit anterior.  
  
</p>
<h3>git reset y reflog: únase en caso de emergencia</h3>

<p>
¿Que pasa cuando todo se rompe y no sabemos que está pasando? Con:<br>


       <span>$ git reset HashDelHEAD </span> <br>

volveremos al estado en que el proyecto funcionaba:
</p>
<ul>
<li><span>$ git reset --soft HashDelHEAD:</span> te mantiene lo que tengas en staging ahí.</li> 
<li><span>$ git reset --hard HashDelHEAD:</span> resetea absolutamente todo lo que tengas en staging.</li> 
</ul>
<p>
git reset es una mala práctica, se recomienda no usarlo; debe ser el último recurso.
</p>
<h3>Buscar en archivos y commits de git con grep y log</h3>
<p>

A medida que se hace más grande el proyecto quieres ir buscando más cosas.
Por ejemplo, ¿ Cuantas veces en nuestro proyecto buscamos la palabra color?
</p>
<ul>
<li>Con <span>$ git grep -n color </span>  nos saldrá un output que nos dirá en que línea está lo que estamos buscando.</li> 
<li> Con  <span>$ git grep -c color</span> nos saldrá un output que nos dirá cuantas veces se repite esa palabra y en que archivos.</li>

<li> Si queremos buscar cuántas veces utilizamos un atributo de HTML lo hacemos con  
  <span>$ git grep -c "etiqueta html"</span></li> 

<li>Si queremos buscar en los commits, por ejemplo la palabra cabecera lo hacemos con: 

  <span>$ git log -S cabecera</span></li> 
</ul>

        </div>
  
      </div>
      </div>
      <div id="footer">
        Lecturas de Git- documentation.https://git-scm.com/docs/
      </div>
     
  </body>
</html>
=======
      <h3>	TEMPORALIDADES, LÍNEAS Y TIPOS DE TENDENCIAS</h3>


<p>La temporalidad son el marco temporal de velas que vamos a trabajar:</p>
<ul>
  <li>	Semanal</li>
  <li>	Diario</li>
  <li>	4 horas</li>
</ul>
<p>A mayor temporalidad, mayor importancia tiene la tendencia.</p>
<p>Las líneas de tendencia son líneas que se trazan sobre el precio de una criptomoneda para analizar su movimiento en un marco temporal especifico.</p>
<p>Tipos de tendencias:</p>
<ul>

  <li>Tendencia alcista: se alcanzan los mínimos y máximos más altos</li>
  <li>Tendencia bajista: Se alcanzan mínimos y máximos cada vez más bajos</li>
  <li>Tendencia lateral: El precio cotiza en un entorno plano.</li>
</ul>

<h3>	RETROCESO FIBONACCI EN TENDENCIAS ALCISTAS</h3>
<p>El retroceso Fibonacci es un método para determinar potenciales niveles de resistencia o soporte en el precio de un instrumento financiero.</p>
<p>Al iniciar el retroceso de una tendencia alcista podemos resolver con la herramienta Fibonacci que nos va a dar diferentes niveles el retroceso se dispara cuando alcanza el nivel de 23%, posteriormente si rompe el 32% se mueve al 38%, si en el 38% se vuelve a romper el nivel sigue hasta el 61%. Este es el punto más importante en un retroceso Fibonacci. Son dos posibles movimientos cuando rompa en el 23% hacer un short hasta el 32% si vuelve a romper el 32% hacer un short hacia el 61%. Si en este punto comienza un nuevo camino alcista  y con  herramientas confirmatorias es el momento de operar en long o comprar.</p>
<p>Se basa en la idea de que el precio rompe una parte predecible de un movimiento original, para después continuar y moverse en la dirección original.</p>
<p>Posterior a un impulso alcista, el precio puede retroceder entre un 0,23 y un 0.61 de Fibonacci y luego retomar su tendencia.</p>
<img src="./images/Retroceso Fibonacci en tendencia alcista.png"/>
<h3>RETROCESO FIBONACCI EN TENDENCIA BAJISTA</h3>
<p>Posterior a un impulso bajista, el precio puede retroceder entre un 0.23 y un 0.61 de Fibonacci y luego retomar tendencia.</p>
<p>Cuando tenemos una tendencia bajista y a partir de ahí el mercado empieza a retroceder y corregir, aplicaremos la herramienta Fibonacci en tendencia bajista de la parte alta a la parte baja. No aparecen las zonas de valores, 0.23, 0.38 y en su defecto la zona del 0,61 que es la zona verdaderamente importante. El punto de 0.23 puede ser una buena zona para comprar en 0.38 y si rompe en 0.38 podemos comprar en long hasta la zona 0.61 como última zona de ganancia operando en long.  Ahora hay que esperar a ver la tendencia si continua alcista o bajista si es bajista se opera en short  hasta la zona 0.38 y si rompe se continua hacia la 0.23 con otras herramientas confirmatorias.</p>
<img src="./images/Retroceso Fibonacci en tendencia bajista.png"/>
<h3>	INDICADORES RSI, DIVERGENCIA ALCISTA Y BAJISTA</h3>
<p>De como el precio actúa en ciertas áreas y aumentar así  las probabilidades de éxito.</p>
<p>El indicador RSI o índice de fuerza relativa es un indicador que mide la posible fuerza de la tendencia en el mercado. Normalmente el indicador se considera sobrecomprado o fuerza compradora fuerte cuando se encuentra arriba de 70, sobrevendido o que tiene una fuerza vendedora fuerte por debajo de 30. Nos fijaremos en la curva RSI cuando cruza los valores de 30 o de 70 ya que cuando se cruzan estos valores pueden haber posibles cambios en los precios. El RSI tiene una funcionalidad bastante importante y es la llamada divergencias. Una divergencia es una señal o un indicativo de que el precio está perdiendo fuerza en la dirección que tenga. No significa que ya los precios van a cambiar o la tendencia va a cambiar inmediatamente, pero es un potenciador de probabilidad que te está diciendo que o bien una tendencia alcista o bajista puede llegar pronto a una corrección o cambio de tendencia completamente.</p>
<p>La divergencia bajista es cuando el precio alcanza un máximo mayor y el indicador hace un máximo menor. Si trazamos una línea del máximo anterior al último máximo haremos lo mismo en el RSI. Cuando el RSI tiene un máximo, pero luego baja. La primera línea va hacia arriba, mientras que la línea del RSI va hacia abajo es una clara divergencia lo que significa que para ese momento podría venir una corrección o podría venir un movimiento bajista.</p>
<img src="./images/RSI_bajista.png"/>
<p>La divergencia alcista es justamente lo contrario. Si los precios van alcanzando los mínimos más bajos y luego realiza otro mínimo. Pero en este caso lo que hace el RSI es pasar de un mínimo a un mínimo mayor este es un indicativo de que la fuerza vendedora está acabando y es posible que hay o un giro en los precios o esté muy cerca de empezar un movimiento alcista por esto que se llama divergencia alcista </p>
<p>RSI o índice de fuerza relativa es un indicador que mide la fuerza del precio, se considera sobrecomprado arriba de 70 y sobrevendido bajo de 30.</p>
<p>La divergencia alcista es cuando veas que los mínimos del indicador suben mientras el precio marca nuevos mínimos. Esta divergencia alcista indica que hay alguna fuerza queriendo levantar el precio y que quizás lo consigue pronto.</p>
<img src="./images/RSI_alcista.png"/>
<h3>	MEDIA MOVIL EXPONENCIAL DE 21</h3>
<p>Las medias móviles las podemos utilizar como confirmación de movimientos para poder empezar a operar en un trade que ya tenemos analizado. Hay diversas medias móviles como la media móvil de 200 que es muy importante o las hay de 30, de 50, en este curso trabajaremos con la media móvil exponencial de 21. No se recomienda trabajar con más de dos medias móviles al mismo tiempo ya que puede obstruir nuestro trabajo con un análisis concreto.</p>
<p>La EMA 21 es una línea que va acompañada al precio y nos va a ir guiando en el proceso. La EMA 21 tiene un papel fundamental en el marco diario de 1D, ya que cuando tenemos una tendencia bajista o alcista el precio busca la media móvil y puede ser un punto de entrada muy bueno para seguir operando a favor de la tendencia o confirma un movimiento podría darse el cambio de tendencia y podría ser un confirmador o un indicador de esta. Esta media móvil nos va a ayudar muchísimo para poder ya definir las entradas que vamos a tener en nuestra operativa como traders. Cuando se rompe a la baja o al alta genera una importante referencia de tendencia.</p>
<p>No es recomendable trabajar con más de dos medias móviles al mismo tiempo, ya que en lugar de ser una ayuda puede obstruir nuestro análisis ya que nos va a arrojar dos resultados diferentes.</p>
<img src="./images/ema21.png"/>
<h3>	PARABOLIC SAR</h3>
<p>El  parabolic SAR es un indicador de ruptura y seguimiento de tendencia. Funciona como confirmador de entrada y como eventual stoploss.</p>
<p>Si ya tenemos el EMA 21 como confirmador de entrada vamos a utilizar el PARABOLIC SAR como una herramienta de stoploss. El PARABOLIC SAR son una serie de puntitos justamente a cierta distancia del precio. Si entramos en una posición vamos a colocar nuestro stoploss por encima de donde si el precio rompe el PARABOLIC SAR vamos a dar la señal o el movimiento invalidado y saldremos del mercado en este momento. Debemos tener herramientas de seguridad en caso de un movimiento inesperado del mercado.</p>
<p>Si vamos tomando ganancias podemos bajar el stoploss desde otro punto más cercano del PARABOLIC SAR.</p>
<p>El stoploss en nuestra zona de entrada garantiza el menor riesgo en la operación ya que si el mercado se moviera en nuestra contra lo único que haría era sacarnos en el punto que hemos entrado y prácticamente no sufriríamos ningún tipo de pérdida en nuestro capital solo tenemos por delante los targets en los que cosechar beneficios.</p>
<p>Si el precio cruza las líneas del PARABOLIC SAR, el indicador da la vuelta y sus siguientes valores se sitúan por otro lado del precio. En caso de esta vuelta del indicador, por el punto de partida se tomará el precio máximo y mínimo del periodo anterior.</p>
<p>Si la posición larga está abierta (es decir, el precio se encuentra por encima de la línea del PARABOLIC SAR entonces la línea del indicador se desplaza hacia arriba independientemente de la dirección en la que se mueven los precios. El valor de desplazamiento de la línea del PARABOLIC SAR depende del valor del movimiento de precios.</p>
<img src="./images/Sar.png"/>
<h3>TRIANGULOS Y BANDERAS</h3>
<p>Los triángulos son figuras de continuación de tendencia, al realizar su ruptura, su proyección de precio equivale a la anchura de su base. Cuando el precio de una acción/commodity se mantiene en un rango de negociación y con el paso del tiempo, dicho rango se hace más pequeño, la contracción del precio y la convergencia de la línea de tendencia conducen a la formación del patrón del triángulo.</p>
<p>El patrón del triángulo se identifica generalmente por la consolidación de la tendencia seguida por una rotura en la dirección de la tendencia establecida.</p>
<img src="./images/Triángulos.png"/>
<p>Las banderas son patrones de precio de continuación, al igual que los triángulos. Son unas de las formaciones chartistas más fáciles de identificar y de aprovechar para operar. Este patrón supone una pausa de la acción del precio, en medio de una tendencia.</p>
<h3>	VELAS JAPONESAS DE CAMBIO DE TENDENCIA</h3>
<p>Los patrones de cambio de tendencia principales son:</p>
<ul>

  <li>	Estrella de la mañana: Es una vela bajista seguida por una vela de indecisión y por último una vela alcista.</li>
  <li>	Estrella de la noche: Es una vela alcista seguida por una vela de indecisión y por último una vela bajista.</li>
  <li>	Torre alta y torre baja: Son similares a la estrella de la mañana y noche, con la diferencia que van seguidas de dos o tres velas.</li>
</ul>
<img src="./images/Velas japonesas.png"/>
<h3>19.	HOMBRO CABEZA HOMBRO</h3>
<p>El hombro cabeza hombro es una figura de cambio de tendencia, su objetivo de precio corresponde a la altura de la cabeza.</p>
<img src="./images/Hombro-cabeza-hombro.png"/>
<p>El doble techo se forma luego de una tendencia alcista madura. Se observa en el gráfico la presencia de dos máximos con niveles similares.</p>
<img src="./images/doble techo.png"/>
<p>El doble piso se forma luego de una tendencia bajista madura. Se identifican cuando el precio toca niveles mínimos relativamente iguales.</p>
<img src="./images/doble piso.png"/>
<p>Las cuñas son figuras de reversión de tendencia. Su objetivo se calcula mediante la altura de su base.</p>
<P>La cuña se diferencia de las formaciones de triángulos en que ambas bandas o líneas entre las que fluctúa el precio apuntan en una misma dirección.</P>
<p>En tendencia alcista las dos líneas serán descendentes, mientras que en tendencia bajista estas líneas serán ascendentes.</p>
<p>Normalmente el precio fluctúa dentro de esta formación con mucha rapidez, al igual que en las banderas y llega casi hasta el vértice de la cuña, es decir, donde confluyen las dos bandas, antes de retomar la tendencia.</p>
<p>Las cuñas suelen estar acompañadas por un descenso en el volumen durante su formación, sin embargo, una vez esté completa la figura el volumen sube de nuevo.</p>
<img src="./images/cuñas.png"/>
<h3>ESTRATEGIAS DE TRADING CON CRIPTOMONEDAS</h3>
<p>Dos estrategias de trading para operar en el bitcoin y las criptomonedas de una manera eficiente y eficaz.</p>
<ul>

<li>Estrategia 1: <br />

<p>Para operar en la continuación de tendencia.</p>
<p>Vamos a buscar el marco de las cuatro horas y buscar un movimiento que haya sido bajista y que empiece a tener un swing alcista. Es decir, el mercado se encuentra en un movimiento alcista precedido de un movimiento bajista anterior. Para ello vamos a buscar que el mercado tenga al menos un 0.23 de corrección ya establecido adicionalmente buscaremos que haya un patrón de cambio de tendencia justamente antes de que el movimiento alcista haya iniciado. Adicionalmente analizaremos que el RSI se encuentre por arriba de la zona de 40 y también buscaremos un cruce en alguna línea de tendencia, así como en una media móvil o así como buscar una figura de continuación de tendencia y la operaremos en la ruptura alcista de la misma. El stoploss siempre debe ir ubicado por debajo del PARABOLIC SAR y los targets van a ser el punto 0.38 y el punto 0.61.</p>
<img src="./images/Estrategia de continuacion de la tendencia.png"/>

</li>
<li>Estrategia 2: <br />
<p>Para operar en el Giro de tendencia:<p>
  <p>Vamos a buscar que el mercado haya alcanzado un movimiento alcista o bajista importante, así como también haya llegado a un punto 0.61 de corrección, es decir que el mercado llegue a un valor Fibonacci que es significativo y que es importante para nosotros. Adicional a eso vamos a buscar que en esa zona clave se esté desarrollando un patrón de cambio de tendencia. Para cuando eso ocurra vamos a analizar que el RSI nos dé una divergencia bajista o una divergencia alcista según el movimiento que estemos buscando. También vamos a buscar una confirmación de entrada en el cruce de la media móvil exponencial y vamos a colocar nuestro stoploss por debajo del PARABOLIC SAR y vamos a buscar también los targets en los puntos 0.38 y 0.61 del movimiento actual</p>
  <img src="./images/estrategia giro de tendencia.png"/>
</li>
</ul>
<h3>PRÁCTICAS SALUDABLES</h3>
<p>Debemos realizar las siguientes prácticas saludables a la hora de hacer trading con criptomonedas:</p>
<ol>

  <li>	Nunca entrar al calor de las emociones</li>
  <li>	Usar 10% del capital máximo por operación</li>
  <li>	Usar un apalancamiento moderado. (2x 3x)</li>
  <li>	Si hay dos targets: tomar ganancia parcial (30-40%) en el primero y poner stop en el punto de entrada.</li>
  <li>	Respetar el Stoploss</li>
  <li>	Utiliza siempre las herramientas conocidas</li>
  <li>	Antes de invertir con dinero, practica con la cuenta demo por un tiempo considerable.</li>
</ol>
<p>Ciclo psicológico del inversionista</p>
<img src="./images/Ciclo psicológico del inversionista.png"/>
    </div>
</div>
<div id="footer">
 Introducción al trading con criptomonedas.
</div>

</body>
</html>   
>>>>>>> 164800e4233961b6e0bb0fed760c1a47413df8c5
